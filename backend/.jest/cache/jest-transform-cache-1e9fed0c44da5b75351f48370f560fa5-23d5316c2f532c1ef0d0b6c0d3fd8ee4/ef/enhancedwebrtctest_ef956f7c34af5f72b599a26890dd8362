f6105f93ca01eae4b8896011737ef73e
const io = require('socket.io-client');
const {
  connectDB,
  closeDB
} = require('../../db/connection');
const User = require('../../models/User');
const jwt = require('jsonwebtoken');
let testUsers = [];
let testTokens = [];
const PORT = 3001;
const TEST_CHANNEL_ID = 'voice-chat-test';
describe('Enhanced WebRTC Testing', () => {
  let clientSockets = [];
  let testClients = [];
  beforeAll(async () => {
    await connectDB();

    // Create multiple test users for comprehensive testing
    for (let i = 1; i <= 5; i++) {
      const user = new User({
        nickname: `webrtc_enhanced_user_${i}`,
        email: `webrtc-enhanced-${i}@test.com`,
        password: 'testpass123'
      });
      await user.save();
      testUsers.push(user);
      const token = jwt.sign({
        id: user._id,
        nickname: user.nickname,
        role: user.role
      }, process.env.JWT_SECRET, {
        expiresIn: '24h'
      });
      testTokens.push(token);
    }
  });
  afterAll(async () => {
    await closeDB();
  });
  beforeEach(done => {
    let connected = 0;
    const totalClients = 3; // Test with 3 concurrent clients

    for (let i = 0; i < totalClients; i++) {
      const socket = io(`http://localhost:${PORT}`, {
        auth: {
          token: testTokens[i]
        }
      });
      socket.on('connect', () => {
        connected++;
        if (connected === totalClients) {
          clientSockets = [];
          testClients = [];
          for (let j = 0; j < totalClients; j++) {
            const sock = io(`http://localhost:${PORT}`, {
              auth: {
                token: testTokens[j]
              }
            });
            clientSockets.push(sock);
            testClients.push({
              socket: sock,
              user: testUsers[j]
            });
          }
          done();
        }
      });
    }
  });
  afterEach(() => {
    clientSockets.forEach(socket => {
      if (socket) socket.disconnect();
    });
  });
  describe('Voice Channel Integrity', () => {
    test('should handle multiple users joining/leaving voice channel', done => {
      let joinedCount = 0;
      let leftCount = 0;
      const expectedEvents = clientSockets.length * 2 + 1; // joins + leaves + final check
      let completedEvents = 0;
      const checkCompletion = () => {
        completedEvents++;
        if (completedEvents === expectedEvents) {
          done();
        }
      };

      // Join all clients to voice channel
      clientSockets.forEach((socket, index) => {
        socket.emit('join_voice_channel', {
          channelId: TEST_CHANNEL_ID
        });
        socket.on('voice_joined', () => {
          joinedCount++;
          expect(joinedCount).toBeLessThanOrEqual(clientSockets.length);
          checkCompletion();
        });
        socket.on('user_joined_voice', data => {
          expect(data.nickname).toBeDefined();
          expect(typeof data.socketId).toBe('string');
        });
      });

      // After joining, have clients leave
      setTimeout(() => {
        clientSockets.forEach(socket => {
          socket.emit('leave_voice_channel');
          socket.on('voice_left', () => {
            leftCount++;
            checkCompletion();
          });
          socket.on('user_left_voice', data => {
            expect(data.nickname).toBeDefined();
            // Verify users are properly cleaned up
            leftCount === clientSockets.length && checkCompletion();
          });
        });
      }, 100);
    });
  });
  describe('Signaling Reliability', () => {
    test('should handle rapid signaling exchange', done => {
      let signalingReceived = 0;
      const rapidSignals = 5;
      const totalSignals = rapidSignals * 2; // offer + answer per pair

      clientSockets.forEach(socket => {
        socket.emit('join_voice_channel', {
          channelId: TEST_CHANNEL_ID
        });
      });
      setTimeout(() => {
        for (let i = 0; i < rapidSignals; i++) {
          const mockOffer = {
            type: 'offer',
            sdp: `mock-sdp-rapid-${i}`
          };

          // Send rapid offers
          clientSockets[0].emit('voice_offer', {
            offer: mockOffer,
            targetSocketId: clientSockets[1].id
          });
          clientSockets[1].on('voice_offer', data => {
            expect(data.offer).toEqual(mockOffer);
            signalingReceived++;

            // Send rapid answers
            clientSockets[1].emit('voice_answer', {
              answer: {
                type: 'answer',
                sdp: `mock-answer-${i}`
              },
              targetSocketId: clientSockets[0].id
            });
            if (signalingReceived >= totalSignals) {
              done();
            }
          });
        }
      }, 50);
    });
    test('should handle signaling with network jitter', done => {
      let receivedOffers = 0;
      let receivedAnswers = 0;
      clientSockets.forEach(socket => {
        socket.emit('join_voice_channel', {
          channelId: TEST_CHANNEL_ID
        });
      });
      setTimeout(() => {
        // Simulate delayed signaling due to network jitter
        const sendSignaling = () => {
          const mockOffer = {
            type: 'offer',
            sdp: 'delayed-sdp'
          };
          clientSockets[0].emit('voice_offer', {
            offer: mockOffer,
            targetSocketId: clientSockets[1].id
          });

          // Simulate variable network delay
          const delay = Math.random() * 200 + 50; // 50-250ms delay

          setTimeout(() => {
            clientSockets[1].emit('voice_answer', {
              answer: {
                type: 'answer',
                sdp: 'delayed-answer'
              },
              targetSocketId: clientSockets[0].id
            });
          }, delay);
        };

        // Multiple signaling attempts with jitter
        for (let i = 0; i < 3; i++) {
          setTimeout(sendSignaling, i * 100);
        }
        clientSockets[1].on('voice_offer', () => {
          receivedOffers++;
        });
        clientSockets[0].on('voice_answer', () => {
          receivedAnswers++;
          if (receivedAnswers === 3) {
            expect(receivedOffers).toBe(3);
            done();
          }
        });
      }, 50);
    });
  });
  describe('Error Handling and Recovery', () => {
    test('should handle invalid signaling data', done => {
      clientSockets[0].emit('join_voice_channel', {
        channelId: TEST_CHANNEL_ID
      });
      clientSockets[0].on('voice_joined', () => {
        const invalidSignals = [{
          offer: null,
          targetSocketId: 'fake-id'
        }, {
          offer: {},
          targetSocketId: clientSockets[1].id
        }, {
          offer: {
            type: 'invalid'
          },
          targetSocketId: clientSockets[1].id
        }, {
          offer: {
            type: 'offer',
            sdp: ''
          },
          targetSocketId: clientSockets[1].id
        }];
        let processedSignals = 0;
        let handledErrors = 0;
        clientSockets[0].on('error', error => {
          console.log('Error received:', error);
          handledErrors++;
        });
        invalidSignals.forEach(invalidSignal => {
          clientSockets[0].emit('voice_offer', invalidSignal);
        });
        setTimeout(() => {
          console.log(`Processed ${processedSignals} signals, handled ${handledErrors} errors`);
          // The test should not crash, regardless of invalid signals
          expect(processedSignals).toBeDefined();
          done();
        }, 1000);
      });
    });
    test('should recover from signaling interruption', done => {
      clientSockets.forEach(socket => {
        socket.emit('join_voice_channel', {
          channelId: TEST_CHANNEL_ID
        });
      });
      setTimeout(() => {
        // Interrupt signaling by simulating connection issues
        clientSockets[0].volatile.emit('voice_offer', {
          offer: {
            type: 'offer',
            sdp: 'interrupt-test'
          },
          targetSocketId: clientSockets[1].id
        });

        // Simulate immediate disconnect and reconnect
        clientSockets[0].disconnect();
        setTimeout(() => {
          const newSocket = io(`http://localhost:${PORT}`, {
            auth: {
              token: testTokens[0]
            }
          });
          newSocket.on('connect', () => {
            newSocket.emit('join_voice_channel', {
              channelId: TEST_CHANNEL_ID
            });
            newSocket.on('voice_joined', () => {
              // Recovery successful - can still join voice channel
              newSocket.disconnect();
              done();
            });
          });
        }, 100);
      }, 50);
    });
    test('should handle concurrent signaling conflicts', done => {
      let receivedSignals = 0;
      const concurrentSignals = 10;
      clientSockets.forEach(socket => {
        socket.emit('join_voice_channel', {
          channelId: TEST_CHANNEL_ID
        });
      });
      setTimeout(() => {
        // Both sockets send offers simultaneously
        for (let i = 0; i < concurrentSignals; i++) {
          const offer1 = {
            type: 'offer',
            sdp: `concurrent-sdp-1-${i}`
          };
          const offer2 = {
            type: 'offer',
            sdp: `concurrent-sdp-2-${i}`
          };
          clientSockets[0].emit('voice_offer', {
            offer: offer1,
            targetSocketId: clientSockets[1].id
          });
          clientSockets[1].emit('voice_offer', {
            offer: offer2,
            targetSocketId: clientSockets[0].id
          });
        }
        let signalCount1 = 0;
        let signalCount2 = 0;
        clientSockets[0].on('voice_offer', () => {
          signalCount1++;
          if (signalCount1 >= concurrentSignals) {
            receivedSignals++;
          }
          if (receivedSignals === 2) {
            done();
          }
        });
        clientSockets[1].on('voice_offer', () => {
          signalCount2++;
          if (signalCount2 >= concurrentSignals) {
            receivedSignals++;
          }
          if (receivedSignals === 2) {
            done();
          }
        });
      }, 50);
    });
  });
  describe('Scalability Testing', () => {
    test('should handle large SDP data', done => {
      // Simulate large SDP data (common in WebRTC)
      const largeSdp = 'v=0\r\n'.repeat(1000) + 'large-sdp-data';
      clientSockets.forEach(socket => {
        socket.emit('join_voice_channel', {
          channelId: TEST_CHANNEL_ID
        });
      });
      setTimeout(() => {
        clientSockets[0].emit('voice_offer', {
          offer: {
            type: 'offer',
            sdp: largeSdp
          },
          targetSocketId: clientSockets[1].id
        });
        clientSockets[1].on('voice_offer', data => {
          expect(data.offer.sdp).toBe(largeSdp);
          expect(data.offer.sdp.length).toBe(largeSdp.length);
          done();
        });
      }, 50);
    });
    test('should handle maximum users in voice channel', done => {
      const maxUsers = 10; // Test reasonable maximum
      const multipleSockets = [];
      let joinedCount = 0;
      let connectedCount = 0;

      // Create maximum number of connections
      for (let i = 0; i < maxUsers && i < testUsers.length; i++) {
        const socket = io(`http://localhost:${PORT}`, {
          auth: {
            token: testTokens[i]
          }
        });
        socket.on('connect', () => {
          connectedCount++;
          if (connectedCount === maxUsers) {
            // All connections established, now join channel
            multipleSockets.forEach(sock => {
              sock.emit('join_voice_channel', {
                channelId: TEST_CHANNEL_ID
              });
              sock.on('voice_joined', () => {
                joinedCount++;
                if (joinedCount === maxUsers) {
                  // Cleanup and complete test
                  multipleSockets.forEach(sock => sock.disconnect());
                  done();
                }
              });
            });
          }
        });
        multipleSockets.push(socket);
      }
    });
  });
  describe('Resource Management', () => {
    test('should properly clean up resources after disconnect', done => {
      clientSockets.forEach(socket => {
        socket.emit('join_voice_channel', {
          channelId: TEST_CHANNEL_ID
        });
      });
      setTimeout(() => {
        // Disconnect all sockets abruptly
        clientSockets.forEach(socket => {
          socket.disconnect();
        });

        // Attempt to reconnect and verify clean state
        setTimeout(() => {
          const reconnectionSocket = io(`http://localhost:${PORT}`, {
            auth: {
              token: testTokens[0]
            }
          });
          reconnectionSocket.on('connect', () => {
            reconnectionSocket.emit('join_voice_channel', {
              channelId: TEST_CHANNEL_ID
            });
            reconnectionSocket.on('voice_joined', () => {
              // Successfully rejoined - resources were cleaned up
              reconnectionSocket.disconnect();
              done();
            });
            reconnectionSocket.on('voice_error', error => {
              // Unexpected error after cleanup
              done(new Error(`Resource cleanup failed: ${error.message}`));
            });
          });
        }, 200);
      }, 50);
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpbyIsInJlcXVpcmUiLCJjb25uZWN0REIiLCJjbG9zZURCIiwiVXNlciIsImp3dCIsInRlc3RVc2VycyIsInRlc3RUb2tlbnMiLCJQT1JUIiwiVEVTVF9DSEFOTkVMX0lEIiwiZGVzY3JpYmUiLCJjbGllbnRTb2NrZXRzIiwidGVzdENsaWVudHMiLCJiZWZvcmVBbGwiLCJpIiwidXNlciIsIm5pY2tuYW1lIiwiZW1haWwiLCJwYXNzd29yZCIsInNhdmUiLCJwdXNoIiwidG9rZW4iLCJzaWduIiwiaWQiLCJfaWQiLCJyb2xlIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJleHBpcmVzSW4iLCJhZnRlckFsbCIsImJlZm9yZUVhY2giLCJkb25lIiwiY29ubmVjdGVkIiwidG90YWxDbGllbnRzIiwic29ja2V0IiwiYXV0aCIsIm9uIiwiaiIsInNvY2siLCJhZnRlckVhY2giLCJmb3JFYWNoIiwiZGlzY29ubmVjdCIsInRlc3QiLCJqb2luZWRDb3VudCIsImxlZnRDb3VudCIsImV4cGVjdGVkRXZlbnRzIiwibGVuZ3RoIiwiY29tcGxldGVkRXZlbnRzIiwiY2hlY2tDb21wbGV0aW9uIiwiaW5kZXgiLCJlbWl0IiwiY2hhbm5lbElkIiwiZXhwZWN0IiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsImRhdGEiLCJ0b0JlRGVmaW5lZCIsInNvY2tldElkIiwidG9CZSIsInNldFRpbWVvdXQiLCJzaWduYWxpbmdSZWNlaXZlZCIsInJhcGlkU2lnbmFscyIsInRvdGFsU2lnbmFscyIsIm1vY2tPZmZlciIsInR5cGUiLCJzZHAiLCJvZmZlciIsInRhcmdldFNvY2tldElkIiwidG9FcXVhbCIsImFuc3dlciIsInJlY2VpdmVkT2ZmZXJzIiwicmVjZWl2ZWRBbnN3ZXJzIiwic2VuZFNpZ25hbGluZyIsImRlbGF5IiwiTWF0aCIsInJhbmRvbSIsImludmFsaWRTaWduYWxzIiwicHJvY2Vzc2VkU2lnbmFscyIsImhhbmRsZWRFcnJvcnMiLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJpbnZhbGlkU2lnbmFsIiwidm9sYXRpbGUiLCJuZXdTb2NrZXQiLCJyZWNlaXZlZFNpZ25hbHMiLCJjb25jdXJyZW50U2lnbmFscyIsIm9mZmVyMSIsIm9mZmVyMiIsInNpZ25hbENvdW50MSIsInNpZ25hbENvdW50MiIsImxhcmdlU2RwIiwicmVwZWF0IiwibWF4VXNlcnMiLCJtdWx0aXBsZVNvY2tldHMiLCJjb25uZWN0ZWRDb3VudCIsInJlY29ubmVjdGlvblNvY2tldCIsIkVycm9yIiwibWVzc2FnZSJdLCJzb3VyY2VzIjpbImVuaGFuY2VkLXdlYnJ0Yy50ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlvID0gcmVxdWlyZSgnc29ja2V0LmlvLWNsaWVudCcpO1xuY29uc3QgeyBjb25uZWN0REIsIGNsb3NlREIgfSA9IHJlcXVpcmUoJy4uLy4uL2RiL2Nvbm5lY3Rpb24nKTtcbmNvbnN0IFVzZXIgPSByZXF1aXJlKCcuLi8uLi9tb2RlbHMvVXNlcicpO1xuY29uc3Qgand0ID0gcmVxdWlyZSgnanNvbndlYnRva2VuJyk7XG5cbmxldCB0ZXN0VXNlcnMgPSBbXTtcbmxldCB0ZXN0VG9rZW5zID0gW107XG5cbmNvbnN0IFBPUlQgPSAzMDAxO1xuY29uc3QgVEVTVF9DSEFOTkVMX0lEID0gJ3ZvaWNlLWNoYXQtdGVzdCc7XG5cbmRlc2NyaWJlKCdFbmhhbmNlZCBXZWJSVEMgVGVzdGluZycsICgpID0+IHtcbiAgbGV0IGNsaWVudFNvY2tldHMgPSBbXTtcbiAgbGV0IHRlc3RDbGllbnRzID0gW107XG5cbiAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBjb25uZWN0REIoKTtcblxuICAgIC8vIENyZWF0ZSBtdWx0aXBsZSB0ZXN0IHVzZXJzIGZvciBjb21wcmVoZW5zaXZlIHRlc3RpbmdcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA1OyBpKyspIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih7XG4gICAgICAgIG5pY2tuYW1lOiBgd2VicnRjX2VuaGFuY2VkX3VzZXJfJHtpfWAsXG4gICAgICAgIGVtYWlsOiBgd2VicnRjLWVuaGFuY2VkLSR7aX1AdGVzdC5jb21gLFxuICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzMTIzJ1xuICAgICAgfSk7XG4gICAgICBhd2FpdCB1c2VyLnNhdmUoKTtcbiAgICAgIHRlc3RVc2Vycy5wdXNoKHVzZXIpO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IGp3dC5zaWduKFxuICAgICAgICB7IGlkOiB1c2VyLl9pZCwgbmlja25hbWU6IHVzZXIubmlja25hbWUsIHJvbGU6IHVzZXIucm9sZSB9LFxuICAgICAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVULFxuICAgICAgICB7IGV4cGlyZXNJbjogJzI0aCcgfVxuICAgICAgKTtcbiAgICAgIHRlc3RUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgfVxuICB9KTtcblxuICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgY2xvc2VEQigpO1xuICB9KTtcblxuICBiZWZvcmVFYWNoKChkb25lKSA9PiB7XG4gICAgbGV0IGNvbm5lY3RlZCA9IDA7XG4gICAgY29uc3QgdG90YWxDbGllbnRzID0gMzsgLy8gVGVzdCB3aXRoIDMgY29uY3VycmVudCBjbGllbnRzXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQ2xpZW50czsgaSsrKSB7XG4gICAgICBjb25zdCBzb2NrZXQgPSBpbyhgaHR0cDovL2xvY2FsaG9zdDoke1BPUlR9YCwge1xuICAgICAgICBhdXRoOiB7IHRva2VuOiB0ZXN0VG9rZW5zW2ldIH1cbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbm5lY3RlZCsrO1xuICAgICAgICBpZiAoY29ubmVjdGVkID09PSB0b3RhbENsaWVudHMpIHtcbiAgICAgICAgICBjbGllbnRTb2NrZXRzID0gW107XG4gICAgICAgICAgdGVzdENsaWVudHMgPSBbXTtcblxuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG90YWxDbGllbnRzOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNvY2sgPSBpbyhgaHR0cDovL2xvY2FsaG9zdDoke1BPUlR9YCwge1xuICAgICAgICAgICAgICBhdXRoOiB7IHRva2VuOiB0ZXN0VG9rZW5zW2pdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50U29ja2V0cy5wdXNoKHNvY2spO1xuICAgICAgICAgICAgdGVzdENsaWVudHMucHVzaCh7IHNvY2tldDogc29jaywgdXNlcjogdGVzdFVzZXJzW2pdIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGNsaWVudFNvY2tldHMuZm9yRWFjaChzb2NrZXQgPT4ge1xuICAgICAgaWYgKHNvY2tldCkgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1ZvaWNlIENoYW5uZWwgSW50ZWdyaXR5JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgdXNlcnMgam9pbmluZy9sZWF2aW5nIHZvaWNlIGNoYW5uZWwnLCAoZG9uZSkgPT4ge1xuICAgICAgbGV0IGpvaW5lZENvdW50ID0gMDtcbiAgICAgIGxldCBsZWZ0Q291bnQgPSAwO1xuICAgICAgY29uc3QgZXhwZWN0ZWRFdmVudHMgPSAoY2xpZW50U29ja2V0cy5sZW5ndGggKiAyKSArIDE7IC8vIGpvaW5zICsgbGVhdmVzICsgZmluYWwgY2hlY2tcbiAgICAgIGxldCBjb21wbGV0ZWRFdmVudHMgPSAwO1xuXG4gICAgICBjb25zdCBjaGVja0NvbXBsZXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbXBsZXRlZEV2ZW50cysrO1xuICAgICAgICBpZiAoY29tcGxldGVkRXZlbnRzID09PSBleHBlY3RlZEV2ZW50cykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSm9pbiBhbGwgY2xpZW50cyB0byB2b2ljZSBjaGFubmVsXG4gICAgICBjbGllbnRTb2NrZXRzLmZvckVhY2goKHNvY2tldCwgaW5kZXgpID0+IHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5fdm9pY2VfY2hhbm5lbCcsIHsgY2hhbm5lbElkOiBURVNUX0NIQU5ORUxfSUQgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCd2b2ljZV9qb2luZWQnLCAoKSA9PiB7XG4gICAgICAgICAgam9pbmVkQ291bnQrKztcbiAgICAgICAgICBleHBlY3Qoam9pbmVkQ291bnQpLnRvQmVMZXNzVGhhbk9yRXF1YWwoY2xpZW50U29ja2V0cy5sZW5ndGgpO1xuICAgICAgICAgIGNoZWNrQ29tcGxldGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ3VzZXJfam9pbmVkX3ZvaWNlJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBleHBlY3QoZGF0YS5uaWNrbmFtZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICBleHBlY3QodHlwZW9mIGRhdGEuc29ja2V0SWQpLnRvQmUoJ3N0cmluZycpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZnRlciBqb2luaW5nLCBoYXZlIGNsaWVudHMgbGVhdmVcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGllbnRTb2NrZXRzLmZvckVhY2goc29ja2V0ID0+IHtcbiAgICAgICAgICBzb2NrZXQuZW1pdCgnbGVhdmVfdm9pY2VfY2hhbm5lbCcpO1xuXG4gICAgICAgICAgc29ja2V0Lm9uKCd2b2ljZV9sZWZ0JywgKCkgPT4ge1xuICAgICAgICAgICAgbGVmdENvdW50Kys7XG4gICAgICAgICAgICBjaGVja0NvbXBsZXRpb24oKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNvY2tldC5vbigndXNlcl9sZWZ0X3ZvaWNlJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChkYXRhLm5pY2tuYW1lKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgLy8gVmVyaWZ5IHVzZXJzIGFyZSBwcm9wZXJseSBjbGVhbmVkIHVwXG4gICAgICAgICAgICBsZWZ0Q291bnQgPT09IGNsaWVudFNvY2tldHMubGVuZ3RoICYmIGNoZWNrQ29tcGxldGlvbigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTaWduYWxpbmcgUmVsaWFiaWxpdHknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSByYXBpZCBzaWduYWxpbmcgZXhjaGFuZ2UnLCAoZG9uZSkgPT4ge1xuICAgICAgbGV0IHNpZ25hbGluZ1JlY2VpdmVkID0gMDtcbiAgICAgIGNvbnN0IHJhcGlkU2lnbmFscyA9IDU7XG4gICAgICBjb25zdCB0b3RhbFNpZ25hbHMgPSByYXBpZFNpZ25hbHMgKiAyOyAvLyBvZmZlciArIGFuc3dlciBwZXIgcGFpclxuXG4gICAgICBjbGllbnRTb2NrZXRzLmZvckVhY2goc29ja2V0ID0+IHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5fdm9pY2VfY2hhbm5lbCcsIHsgY2hhbm5lbElkOiBURVNUX0NIQU5ORUxfSUQgfSk7XG4gICAgICB9KTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFwaWRTaWduYWxzOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBtb2NrT2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogYG1vY2stc2RwLXJhcGlkLSR7aX1gIH07XG5cbiAgICAgICAgICAvLyBTZW5kIHJhcGlkIG9mZmVyc1xuICAgICAgICAgIGNsaWVudFNvY2tldHNbMF0uZW1pdCgndm9pY2Vfb2ZmZXInLCB7XG4gICAgICAgICAgICBvZmZlcjogbW9ja09mZmVyLFxuICAgICAgICAgICAgdGFyZ2V0U29ja2V0SWQ6IGNsaWVudFNvY2tldHNbMV0uaWRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNsaWVudFNvY2tldHNbMV0ub24oJ3ZvaWNlX29mZmVyJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChkYXRhLm9mZmVyKS50b0VxdWFsKG1vY2tPZmZlcik7XG4gICAgICAgICAgICBzaWduYWxpbmdSZWNlaXZlZCsrO1xuXG4gICAgICAgICAgICAvLyBTZW5kIHJhcGlkIGFuc3dlcnNcbiAgICAgICAgICAgIGNsaWVudFNvY2tldHNbMV0uZW1pdCgndm9pY2VfYW5zd2VyJywge1xuICAgICAgICAgICAgICBhbnN3ZXI6IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogYG1vY2stYW5zd2VyLSR7aX1gIH0sXG4gICAgICAgICAgICAgIHRhcmdldFNvY2tldElkOiBjbGllbnRTb2NrZXRzWzBdLmlkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHNpZ25hbGluZ1JlY2VpdmVkID49IHRvdGFsU2lnbmFscykge1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDUwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgc2lnbmFsaW5nIHdpdGggbmV0d29yayBqaXR0ZXInLCAoZG9uZSkgPT4ge1xuICAgICAgbGV0IHJlY2VpdmVkT2ZmZXJzID0gMDtcbiAgICAgIGxldCByZWNlaXZlZEFuc3dlcnMgPSAwO1xuXG4gICAgICBjbGllbnRTb2NrZXRzLmZvckVhY2goc29ja2V0ID0+IHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5fdm9pY2VfY2hhbm5lbCcsIHsgY2hhbm5lbElkOiBURVNUX0NIQU5ORUxfSUQgfSk7XG4gICAgICB9KTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIFNpbXVsYXRlIGRlbGF5ZWQgc2lnbmFsaW5nIGR1ZSB0byBuZXR3b3JrIGppdHRlclxuICAgICAgICBjb25zdCBzZW5kU2lnbmFsaW5nID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vY2tPZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiAnZGVsYXllZC1zZHAnIH07XG5cbiAgICAgICAgICBjbGllbnRTb2NrZXRzWzBdLmVtaXQoJ3ZvaWNlX29mZmVyJywge1xuICAgICAgICAgICAgb2ZmZXI6IG1vY2tPZmZlcixcbiAgICAgICAgICAgIHRhcmdldFNvY2tldElkOiBjbGllbnRTb2NrZXRzWzFdLmlkXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTaW11bGF0ZSB2YXJpYWJsZSBuZXR3b3JrIGRlbGF5XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLnJhbmRvbSgpICogMjAwICsgNTA7IC8vIDUwLTI1MG1zIGRlbGF5XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNsaWVudFNvY2tldHNbMV0uZW1pdCgndm9pY2VfYW5zd2VyJywge1xuICAgICAgICAgICAgICBhbnN3ZXI6IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogJ2RlbGF5ZWQtYW5zd2VyJyB9LFxuICAgICAgICAgICAgICB0YXJnZXRTb2NrZXRJZDogY2xpZW50U29ja2V0c1swXS5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE11bHRpcGxlIHNpZ25hbGluZyBhdHRlbXB0cyB3aXRoIGppdHRlclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHNldFRpbWVvdXQoc2VuZFNpZ25hbGluZywgaSAqIDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGllbnRTb2NrZXRzWzFdLm9uKCd2b2ljZV9vZmZlcicsICgpID0+IHtcbiAgICAgICAgICByZWNlaXZlZE9mZmVycysrO1xuICAgICAgICB9KTtcblxuICAgICAgICBjbGllbnRTb2NrZXRzWzBdLm9uKCd2b2ljZV9hbnN3ZXInLCAoKSA9PiB7XG4gICAgICAgICAgcmVjZWl2ZWRBbnN3ZXJzKys7XG4gICAgICAgICAgaWYgKHJlY2VpdmVkQW5zd2VycyA9PT0gMykge1xuICAgICAgICAgICAgZXhwZWN0KHJlY2VpdmVkT2ZmZXJzKS50b0JlKDMpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCA1MCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZyBhbmQgUmVjb3ZlcnknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHNpZ25hbGluZyBkYXRhJywgKGRvbmUpID0+IHtcbiAgICAgIGNsaWVudFNvY2tldHNbMF0uZW1pdCgnam9pbl92b2ljZV9jaGFubmVsJywgeyBjaGFubmVsSWQ6IFRFU1RfQ0hBTk5FTF9JRCB9KTtcblxuICAgICAgY2xpZW50U29ja2V0c1swXS5vbigndm9pY2Vfam9pbmVkJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnZhbGlkU2lnbmFscyA9IFtcbiAgICAgICAgICB7IG9mZmVyOiBudWxsLCB0YXJnZXRTb2NrZXRJZDogJ2Zha2UtaWQnIH0sXG4gICAgICAgICAgeyBvZmZlcjoge30sIHRhcmdldFNvY2tldElkOiBjbGllbnRTb2NrZXRzWzFdLmlkIH0sXG4gICAgICAgICAgeyBvZmZlcjogeyB0eXBlOiAnaW52YWxpZCcgfSwgdGFyZ2V0U29ja2V0SWQ6IGNsaWVudFNvY2tldHNbMV0uaWQgfSxcbiAgICAgICAgICB7IG9mZmVyOiB7IHR5cGU6ICdvZmZlcicsIHNkcDogJycgfSwgdGFyZ2V0U29ja2V0SWQ6IGNsaWVudFNvY2tldHNbMV0uaWQgfVxuICAgICAgICBdO1xuXG4gICAgICAgIGxldCBwcm9jZXNzZWRTaWduYWxzID0gMDtcbiAgICAgICAgbGV0IGhhbmRsZWRFcnJvcnMgPSAwO1xuXG4gICAgICAgIGNsaWVudFNvY2tldHNbMF0ub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHJlY2VpdmVkOicsIGVycm9yKTtcbiAgICAgICAgICBoYW5kbGVkRXJyb3JzKys7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGludmFsaWRTaWduYWxzLmZvckVhY2goaW52YWxpZFNpZ25hbCA9PiB7XG4gICAgICAgICAgY2xpZW50U29ja2V0c1swXS5lbWl0KCd2b2ljZV9vZmZlcicsIGludmFsaWRTaWduYWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2VkICR7cHJvY2Vzc2VkU2lnbmFsc30gc2lnbmFscywgaGFuZGxlZCAke2hhbmRsZWRFcnJvcnN9IGVycm9yc2ApO1xuICAgICAgICAgIC8vIFRoZSB0ZXN0IHNob3VsZCBub3QgY3Jhc2gsIHJlZ2FyZGxlc3Mgb2YgaW52YWxpZCBzaWduYWxzXG4gICAgICAgICAgZXhwZWN0KHByb2Nlc3NlZFNpZ25hbHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlY292ZXIgZnJvbSBzaWduYWxpbmcgaW50ZXJydXB0aW9uJywgKGRvbmUpID0+IHtcbiAgICAgIGNsaWVudFNvY2tldHMuZm9yRWFjaChzb2NrZXQgPT4ge1xuICAgICAgICBzb2NrZXQuZW1pdCgnam9pbl92b2ljZV9jaGFubmVsJywgeyBjaGFubmVsSWQ6IFRFU1RfQ0hBTk5FTF9JRCB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gSW50ZXJydXB0IHNpZ25hbGluZyBieSBzaW11bGF0aW5nIGNvbm5lY3Rpb24gaXNzdWVzXG4gICAgICAgIGNsaWVudFNvY2tldHNbMF0udm9sYXRpbGUuZW1pdCgndm9pY2Vfb2ZmZXInLCB7XG4gICAgICAgICAgb2ZmZXI6IHsgdHlwZTogJ29mZmVyJywgc2RwOiAnaW50ZXJydXB0LXRlc3QnIH0sXG4gICAgICAgICAgdGFyZ2V0U29ja2V0SWQ6IGNsaWVudFNvY2tldHNbMV0uaWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2ltdWxhdGUgaW1tZWRpYXRlIGRpc2Nvbm5lY3QgYW5kIHJlY29ubmVjdFxuICAgICAgICBjbGllbnRTb2NrZXRzWzBdLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTb2NrZXQgPSBpbyhgaHR0cDovL2xvY2FsaG9zdDoke1BPUlR9YCwge1xuICAgICAgICAgICAgYXV0aDogeyB0b2tlbjogdGVzdFRva2Vuc1swXSB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBuZXdTb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICBuZXdTb2NrZXQuZW1pdCgnam9pbl92b2ljZV9jaGFubmVsJywgeyBjaGFubmVsSWQ6IFRFU1RfQ0hBTk5FTF9JRCB9KTtcblxuICAgICAgICAgICAgbmV3U29ja2V0Lm9uKCd2b2ljZV9qb2luZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIFJlY292ZXJ5IHN1Y2Nlc3NmdWwgLSBjYW4gc3RpbGwgam9pbiB2b2ljZSBjaGFubmVsXG4gICAgICAgICAgICAgIG5ld1NvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfSwgNTApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IHNpZ25hbGluZyBjb25mbGljdHMnLCAoZG9uZSkgPT4ge1xuICAgICAgbGV0IHJlY2VpdmVkU2lnbmFscyA9IDA7XG4gICAgICBjb25zdCBjb25jdXJyZW50U2lnbmFscyA9IDEwO1xuXG4gICAgICBjbGllbnRTb2NrZXRzLmZvckVhY2goc29ja2V0ID0+IHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5fdm9pY2VfY2hhbm5lbCcsIHsgY2hhbm5lbElkOiBURVNUX0NIQU5ORUxfSUQgfSk7XG4gICAgICB9KTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIEJvdGggc29ja2V0cyBzZW5kIG9mZmVycyBzaW11bHRhbmVvdXNseVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmN1cnJlbnRTaWduYWxzOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBvZmZlcjEgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogYGNvbmN1cnJlbnQtc2RwLTEtJHtpfWAgfTtcbiAgICAgICAgICBjb25zdCBvZmZlcjIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogYGNvbmN1cnJlbnQtc2RwLTItJHtpfWAgfTtcblxuICAgICAgICAgIGNsaWVudFNvY2tldHNbMF0uZW1pdCgndm9pY2Vfb2ZmZXInLCB7XG4gICAgICAgICAgICBvZmZlcjogb2ZmZXIxLFxuICAgICAgICAgICAgdGFyZ2V0U29ja2V0SWQ6IGNsaWVudFNvY2tldHNbMV0uaWRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNsaWVudFNvY2tldHNbMV0uZW1pdCgndm9pY2Vfb2ZmZXInLCB7XG4gICAgICAgICAgICBvZmZlcjogb2ZmZXIyLFxuICAgICAgICAgICAgdGFyZ2V0U29ja2V0SWQ6IGNsaWVudFNvY2tldHNbMF0uaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzaWduYWxDb3VudDEgPSAwO1xuICAgICAgICBsZXQgc2lnbmFsQ291bnQyID0gMDtcblxuICAgICAgICBjbGllbnRTb2NrZXRzWzBdLm9uKCd2b2ljZV9vZmZlcicsICgpID0+IHtcbiAgICAgICAgICBzaWduYWxDb3VudDErKztcbiAgICAgICAgICBpZiAoc2lnbmFsQ291bnQxID49IGNvbmN1cnJlbnRTaWduYWxzKSB7XG4gICAgICAgICAgICByZWNlaXZlZFNpZ25hbHMrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlY2VpdmVkU2lnbmFscyA9PT0gMikge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xpZW50U29ja2V0c1sxXS5vbigndm9pY2Vfb2ZmZXInLCAoKSA9PiB7XG4gICAgICAgICAgc2lnbmFsQ291bnQyKys7XG4gICAgICAgICAgaWYgKHNpZ25hbENvdW50MiA+PSBjb25jdXJyZW50U2lnbmFscykge1xuICAgICAgICAgICAgcmVjZWl2ZWRTaWduYWxzKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWNlaXZlZFNpZ25hbHMgPT09IDIpIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgNTApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2NhbGFiaWxpdHkgVGVzdGluZycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGxhcmdlIFNEUCBkYXRhJywgKGRvbmUpID0+IHtcbiAgICAgIC8vIFNpbXVsYXRlIGxhcmdlIFNEUCBkYXRhIChjb21tb24gaW4gV2ViUlRDKVxuICAgICAgY29uc3QgbGFyZ2VTZHAgPSAndj0wXFxyXFxuJy5yZXBlYXQoMTAwMCkgKyAnbGFyZ2Utc2RwLWRhdGEnO1xuXG4gICAgICBjbGllbnRTb2NrZXRzLmZvckVhY2goc29ja2V0ID0+IHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5fdm9pY2VfY2hhbm5lbCcsIHsgY2hhbm5lbElkOiBURVNUX0NIQU5ORUxfSUQgfSk7XG4gICAgICB9KTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsaWVudFNvY2tldHNbMF0uZW1pdCgndm9pY2Vfb2ZmZXInLCB7XG4gICAgICAgICAgb2ZmZXI6IHsgdHlwZTogJ29mZmVyJywgc2RwOiBsYXJnZVNkcCB9LFxuICAgICAgICAgIHRhcmdldFNvY2tldElkOiBjbGllbnRTb2NrZXRzWzFdLmlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNsaWVudFNvY2tldHNbMV0ub24oJ3ZvaWNlX29mZmVyJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBleHBlY3QoZGF0YS5vZmZlci5zZHApLnRvQmUobGFyZ2VTZHApO1xuICAgICAgICAgIGV4cGVjdChkYXRhLm9mZmVyLnNkcC5sZW5ndGgpLnRvQmUobGFyZ2VTZHAubGVuZ3RoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgNTApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtYXhpbXVtIHVzZXJzIGluIHZvaWNlIGNoYW5uZWwnLCAoZG9uZSkgPT4ge1xuICAgICAgY29uc3QgbWF4VXNlcnMgPSAxMDsgLy8gVGVzdCByZWFzb25hYmxlIG1heGltdW1cbiAgICAgIGNvbnN0IG11bHRpcGxlU29ja2V0cyA9IFtdO1xuICAgICAgbGV0IGpvaW5lZENvdW50ID0gMDtcbiAgICAgIGxldCBjb25uZWN0ZWRDb3VudCA9IDA7XG5cbiAgICAgIC8vIENyZWF0ZSBtYXhpbXVtIG51bWJlciBvZiBjb25uZWN0aW9uc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhVc2VycyAmJiBpIDwgdGVzdFVzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7UE9SVH1gLCB7XG4gICAgICAgICAgYXV0aDogeyB0b2tlbjogdGVzdFRva2Vuc1tpXSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBjb25uZWN0ZWRDb3VudCsrO1xuICAgICAgICAgIGlmIChjb25uZWN0ZWRDb3VudCA9PT0gbWF4VXNlcnMpIHtcbiAgICAgICAgICAgIC8vIEFsbCBjb25uZWN0aW9ucyBlc3RhYmxpc2hlZCwgbm93IGpvaW4gY2hhbm5lbFxuICAgICAgICAgICAgbXVsdGlwbGVTb2NrZXRzLmZvckVhY2goc29jayA9PiB7XG4gICAgICAgICAgICAgIHNvY2suZW1pdCgnam9pbl92b2ljZV9jaGFubmVsJywgeyBjaGFubmVsSWQ6IFRFU1RfQ0hBTk5FTF9JRCB9KTtcbiAgICAgICAgICAgICAgc29jay5vbigndm9pY2Vfam9pbmVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGpvaW5lZENvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKGpvaW5lZENvdW50ID09PSBtYXhVc2Vycykge1xuICAgICAgICAgICAgICAgICAgLy8gQ2xlYW51cCBhbmQgY29tcGxldGUgdGVzdFxuICAgICAgICAgICAgICAgICAgbXVsdGlwbGVTb2NrZXRzLmZvckVhY2goc29jayA9PiBzb2NrLmRpc2Nvbm5lY3QoKSk7XG4gICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbXVsdGlwbGVTb2NrZXRzLnB1c2goc29ja2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Jlc291cmNlIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHByb3Blcmx5IGNsZWFuIHVwIHJlc291cmNlcyBhZnRlciBkaXNjb25uZWN0JywgKGRvbmUpID0+IHtcbiAgICAgIGNsaWVudFNvY2tldHMuZm9yRWFjaChzb2NrZXQgPT4ge1xuICAgICAgICBzb2NrZXQuZW1pdCgnam9pbl92b2ljZV9jaGFubmVsJywgeyBjaGFubmVsSWQ6IFRFU1RfQ0hBTk5FTF9JRCB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gRGlzY29ubmVjdCBhbGwgc29ja2V0cyBhYnJ1cHRseVxuICAgICAgICBjbGllbnRTb2NrZXRzLmZvckVhY2goc29ja2V0ID0+IHtcbiAgICAgICAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBdHRlbXB0IHRvIHJlY29ubmVjdCBhbmQgdmVyaWZ5IGNsZWFuIHN0YXRlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlY29ubmVjdGlvblNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7UE9SVH1gLCB7XG4gICAgICAgICAgICBhdXRoOiB7IHRva2VuOiB0ZXN0VG9rZW5zWzBdIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlY29ubmVjdGlvblNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgIHJlY29ubmVjdGlvblNvY2tldC5lbWl0KCdqb2luX3ZvaWNlX2NoYW5uZWwnLCB7IGNoYW5uZWxJZDogVEVTVF9DSEFOTkVMX0lEIH0pO1xuXG4gICAgICAgICAgICByZWNvbm5lY3Rpb25Tb2NrZXQub24oJ3ZvaWNlX2pvaW5lZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IHJlam9pbmVkIC0gcmVzb3VyY2VzIHdlcmUgY2xlYW5lZCB1cFxuICAgICAgICAgICAgICByZWNvbm5lY3Rpb25Tb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVjb25uZWN0aW9uU29ja2V0Lm9uKCd2b2ljZV9lcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVycm9yIGFmdGVyIGNsZWFudXBcbiAgICAgICAgICAgICAgZG9uZShuZXcgRXJyb3IoYFJlc291cmNlIGNsZWFudXAgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4g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