de1239f820526642e9df2cadf67291a7
const io = require('socket.io-client');
const jwt = require('jsonwebtoken');
const {
  connectDB,
  closeDB
} = require('../db/connection');
const User = require('../models/User');
const Channel = require('../models/Channel');
const Message = require('../models/Message');
const SocketTestServer = require('./socket-server.test');

// Utility function to wait for socket event with timeout and retry
function waitForEvent(socket, eventName, timeout = 5000, retryCount = 3) {
  return new Promise((resolve, reject) => {
    let resolved = false;
    let attempts = 0;
    const cleanup = () => {
      socket.off(eventName, eventHandler);
      clearTimeout(timeoutId);
    };
    const eventHandler = data => {
      if (!resolved) {
        resolved = true;
        cleanup();
        resolve(data);
      }
    };
    const tryWait = () => {
      if (resolved || attempts >= retryCount) return;
      const timeoutId = setTimeout(() => {
        if (!resolved) {
          attempts++;
          if (attempts < retryCount) {
            tryWait(); // Retry
          } else {
            cleanup();
            reject(new Error(`Event '${eventName}' not received after ${retryCount} attempts (${timeout * retryCount}ms)`));
          }
        }
      }, timeout);
      if (!resolved) {
        socket.once(eventName, eventHandler);
      }
    };
    tryWait();
  });
}

// Utility function to wait for socket connection with timeout
function waitForSocketConnection(socket, timeout = 5000) {
  return new Promise((resolve, reject) => {
    if (socket.connected) {
      resolve(socket);
      return;
    }
    let resolved = false;
    let cleanup = () => {
      socket.off('connect', connectHandler);
      socket.off('connect_error', errorHandler);
      clearTimeout(timeoutId);
    };
    const connectHandler = () => {
      if (!resolved) {
        resolved = true;
        cleanup();
        resolve(socket);
      }
    };
    const errorHandler = error => {
      if (!resolved) {
        resolved = true;
        cleanup();
        reject(new Error(`Socket connection failed: ${error.message}`));
      }
    };
    const timeoutId = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        cleanup();
        reject(new Error(`Socket connection timeout after ${timeout}ms`));
      }
    }, timeout);
    socket.on('connect', connectHandler);
    socket.on('connect_error', errorHandler);
  });
}

// Utility function to simulate network latency
function simulateLatency(socket, latency = 100) {
  const originalEmit = socket.emit.bind(socket);
  socket.emit = (...args) => {
    return new Promise(resolve => {
      setTimeout(() => {
        originalEmit(...args);
        resolve();
      }, latency);
    });
  };
}

// Retry utility for operations
async function retryOperation(operation, maxRetries = 3, delay = 1000) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      if (attempt === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
let testServer;
let testUser;
let testToken;
let serverPort;
describe('Socket.IO Extended Tests - Improved Stability', () => {
  beforeAll(async () => {
    jest.setTimeout(90000); // Increase timeout for full test suite

    await retryOperation(async () => {
      await connectDB();
    }, 3, 2000);
    testServer = new SocketTestServer();
    serverPort = await retryOperation(async () => {
      return await testServer.start();
    }, 3, 2000);
    testUser = new User({
      nickname: 'extendedSocketTestUser',
      email: 'extended-socket@test.com',
      password: 'testpass123',
      status: 'online'
    });
    await testUser.save();

    // Create test channels with better error handling
    try {
      await Channel.findOneAndUpdate({
        id: 'general'
      }, {
        id: 'general',
        name: 'General Chat',
        type: 'text',
        createdBy: 'system'
      }, {
        upsert: true,
        new: true
      });
      await Channel.findOneAndUpdate({
        id: 'voice-chat'
      }, {
        id: 'voice-chat',
        name: 'Voice Chat',
        type: 'voice',
        createdBy: 'system'
      }, {
        upsert: true,
        new: true
      });
      await Channel.findOneAndUpdate({
        id: 'private-test'
      }, {
        id: 'private-test',
        name: 'Private Test',
        type: 'text',
        createdBy: 'system'
      }, {
        upsert: true,
        new: true
      });
    } catch (error) {
      console.warn('Channel creation warning:', error.message);
    }

    // Create JWT token
    testToken = jwt.sign({
      id: testUser._id,
      nickname: testUser.nickname,
      role: testUser.role
    }, process.env.JWT_SECRET, {
      expiresIn: '24h'
    });
  });
  afterAll(async () => {
    if (testServer) {
      await testServer.stop();
    }
    await closeDB();
  });
  describe('Authentication Edge Cases', () => {
    test('should reject invalid JWT token', async () => {
      const invalidSocket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: 'invalid-token'
        },
        forceNew: true
      });
      let caughtError = null;
      invalidSocket.on('connect_error', error => {
        caughtError = error;
      });

      // Wait for connection attempt to fail
      await expect(waitForSocketConnection(invalidSocket, 3000)).rejects.toThrow();
      expect(caughtError).toBeTruthy();
      invalidSocket.disconnect();
    });
    test('should reject connection without token', async () => {
      const noTokenSocket = io(`http://localhost:${serverPort}`, {
        forceNew: true
      });
      let caughtError = null;
      noTokenSocket.on('connect_error', error => {
        caughtError = error;
      });
      await expect(waitForSocketConnection(noTokenSocket, 3000)).rejects.toThrow();
      expect(caughtError).toBeTruthy();
      noTokenSocket.disconnect();
    });
  });
  describe('Private Messages - /w Command Edge Cases', () => {
    let clientSocket, secondSocket;
    beforeEach(done => {
      const secondUser = new User({
        nickname: 'extendedTestUser2',
        email: 'extended-test2@test.com',
        password: 'testpass123',
        status: 'online'
      });
      secondUser.save().then(() => {
        const secondToken = jwt.sign({
          id: secondUser._id,
          nickname: secondUser.nickname,
          role: secondUser.role
        }, process.env.JWT_SECRET, {
          expiresIn: '24h'
        });
        clientSocket = io(`http://localhost:${serverPort}`, {
          auth: {
            token: testToken
          },
          forceNew: true
        });
        secondSocket = io(`http://localhost:${serverPort}`, {
          auth: {
            token: secondToken
          },
          forceNew: true
        });
        secondSocket.on('connect', () => {
          clientSocket.emit('join_room', {
            room: 'general'
          });
          secondSocket.emit('join_room', {
            room: 'general'
          });
          done();
        });
        logger.info('Connecting secondDebugger socket with token:', secondToken.substring(0, 20) + '...');
        logger.info('TestUser ID:', testUser._id, 'Status:', testUser.status);
        secondSocket.on('connect_error', error => {
          done(new Error(`Second socket failed: ${error.message}`));
        });
      });
    });
    afterEach(() => {
      if (clientSocket) clientSocket.disconnect();
      if (secondSocket) secondSocket.disconnect();
    });
    test('should send private message between users', async () => {
      const privateMessage = 'Private message from extended test';

      // Wait for both sockets to be ready
      await retryOperation(async () => {
        await Promise.all([waitForSocketConnection(clientSocket), waitForSocketConnection(secondSocket)]);
      });

      // Emit the message
      clientSocket.emit('private_message', {
        to: 'extendedTestUser2',
        text: privateMessage
      });

      // Wait for both sides to receive the message
      const [senderData, receiverData] = await Promise.all([waitForEvent(clientSocket, 'private_message'), waitForEvent(secondSocket, 'private_message')]);
      expect(senderData.text).toBe(privateMessage);
      expect(receiverData.text).toBe(privateMessage);
      expect(receiverData.author).toBe(testUser.nickname);
      expect(receiverData.from || receiverData.author).toBe(testUser.nickname);
    });
  });
  describe('Message History and Archival', () => {
    let clientSocket;
    beforeEach(done => {
      clientSocket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      clientSocket.on('connect', () => {
        done();
      });
      clientSocket.on('connect_error', error => {
        done(new Error(`Connection failed: ${error.message}`));
      });
    });
    afterEach(() => {
      if (clientSocket) clientSocket.disconnect();
    });
    test('should receive history when joining room', async () => {
      // Send a test message first
      await retryOperation(async () => {
        await waitForSocketConnection(clientSocket);
      });
      clientSocket.emit('join_room', {
        room: 'general'
      });

      // Wait for history event
      const history = await waitForEvent(clientSocket, 'history');
      expect(Array.isArray(history)).toBe(true);
      if (history.length > 0) {
        expect(history[0]).toHaveProperty('author');
        expect(history[0]).toHaveProperty('text');
        expect(history[0]).toHaveProperty('timestamp');
      }
    });
    test('should handle history request without room', done => {
      clientSocket.emit('get_history');
      clientSocket.on('history', messages => {
        expect(Array.isArray(messages)).toBe(true);
        done();
      });
    });
  });
  describe('Room Switching and Channel Validation', () => {
    test('should handle invalid room names', done => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      socket.on('connect', () => {
        socket.emit('join_room', {
          room: ''
        });
        socket.on('error', data => {
          expect(data.code).toBe('INVALID_ROOM_FORMAT');
          socket.disconnect();
          done();
        });
      });
      socket.on('connect_error', error => {
        done(new Error(`Connection failed: ${error.message}`));
      });
    });
    test('should handle non-existent channel', done => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      socket.on('connect', () => {
        socket.emit('join_room', {
          room: 'non-existent-channel'
        });
        socket.on('error', data => {
          expect(data.code).toBe('CHANNEL_NOT_FOUND');
          socket.disconnect();
          done();
        });
      });
    });
  });
  describe('Connection Management and Recovery', () => {
    test('should handle connection recovery after disconnect', async () => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true,
        reconnection: true,
        reconnectionDelay: 500
      });
      await waitForSocketConnection(socket);
      expect(socket.connected).toBe(true);

      // Disconnect and wait for reconnection
      socket.disconnect();

      // Wait for disconnect event
      await waitForEvent(socket, 'disconnect');

      // Create new connection (automatic reconnection would be ideal but may not work reliably)
      const newSocket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      await waitForSocketConnection(newSocket);
      expect(newSocket.connected).toBe(true);
      newSocket.disconnect();
    });
    test('should handle rapid connections', async () => {
      const totalSockets = 3;
      const sockets = [];

      // Create all sockets at once using Promise.all
      const connectionPromises = Array.from({
        length: totalSockets
      }, async (_, i) => {
        const socket = io(`http://localhost:${serverPort}`, {
          auth: {
            token: testToken
          },
          forceNew: true
        });
        await waitForSocketConnection(socket);
        sockets.push(socket);
        return socket;
      });

      // Wait for all connections simultaneously
      await Promise.all(connectionPromises);
      expect(sockets.length).toBe(totalSockets);

      // Clean up
      sockets.forEach(sock => sock.disconnect());
    });
  });
  describe('Advanced Voice Channel Scenarios', () => {
    test('should reject joining text channel as voice channel', done => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      socket.on('connect', () => {
        socket.emit('join_voice_channel', {
          channelId: 'general'
        }); // Text channel
        socket.on('voice_error', data => {
          expect(data.message).toBe('Voice channel not found');
          socket.disconnect();
          done();
        });
      });
    });
    test('should join voice channel without room first', done => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      socket.on('connect', () => {
        socket.emit('join_voice_channel', {
          channelId: 'voice-chat'
        });
        socket.on('voice_joined', data => {
          expect(data.channelId).toBe('voice-chat');
          socket.disconnect();
          done();
        });
      });
    });
  });
  describe('Rate Limiting and Performance', () => {
    test('should maintain performance under load', done => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      socket.on('connect', () => {
        const startTime = Date.now();
        let operationCount = 0;
        const targetOperations = 20;
        const performOperation = () => {
          socket.emit('message', {
            text: `Load test ${operationCount + 1}`
          });
          operationCount++;
          if (operationCount >= targetOperations) {
            const endTime = Date.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(5000); // 5 seconds max
            socket.disconnect();
            done();
          } else {
            setTimeout(performOperation, 50);
          }
        };
        socket.emit('join_room', {
          room: 'general'
        });
        socket.on('online_users', () => {
          performOperation();
        });
      });
      socket.on('connect_error', error => {
        done(new Error(`Connection failed: ${error.message}`));
      });
    });
  });
  describe('Error Recovery and Resilience', () => {
    test('should handle malformed messages gracefully', done => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      socket.on('connect', () => {
        socket.emit('join_room', {
          room: 'general'
        });
        socket.on('online_users', () => {
          const malformedMessages = [null, undefined, {
            text: ''
          }, {
            text: '   '
          }, {}];
          malformedMessages.forEach(malformed => {
            socket.emit('message', malformed);
          });
          setTimeout(() => {
            expect(true).toBe(true); // Test passes if no errors thrown
            socket.disconnect();
            done();
          }, 1000);
        });
      });
      socket.on('connect_error', error => {
        done(new Error(`Connection failed: ${error.message}`));
      });
    });
  });
  describe('Network Conditions Emulation', () => {
    test('should handle high latency connections', async () => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });

      // Simulate latency by monkey-patching the emit method
      simulateLatency(socket);
      await waitForSocketConnection(socket, 10000); // Increased timeout for latency

      socket.emit('join_room', {
        room: 'general'
      });
      const data = await waitForEvent(socket, 'message', 10000);
      expect(data.author).toBe('System');
      socket.disconnect();
    });
    test('should handle connection drops and recovery', async () => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true,
        reconnection: true,
        reconnectionDelay: 100,
        reconnectionAttempts: 5
      });
      await waitForSocketConnection(socket);
      socket.emit('join_room', {
        room: 'general'
      });
      await waitForEvent(socket, 'online_users');

      // Forcefully disconnect the socket
      socket.disconnect();

      // The test passes if we reach here without hanging
      expect(true).toBe(true);
    });
    test('should retry failed operations', async () => {
      let retryCount = 0;
      const mockOperation = async () => {
        retryCount++;
        if (retryCount < 2) {
          throw new Error('Simulated network error');
        }
        return 'success';
      };
      const result = await retryOperation(mockOperation, 3, 10); // Very short delay for testing
      expect(result).toBe('success');
      expect(retryCount).toBe(2);
    });
    test('should handle multiple simultaneous operations with Promise.all', async () => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      await waitForSocketConnection(socket);
      socket.emit('join_room', {
        room: 'general'
      });

      // Create multiple promises that should complete simultaneously
      const promises = [waitForEvent(socket, 'online_users'), new Promise(resolve => setTimeout(resolve, 100)).then(() => 'delay'), retryOperation(async () => {
        socket.emit('message', {
          text: 'Concurrent test message'
        });
        return waitForEvent(socket, 'message');
      })];
      const results = await Promise.all(promises);
      expect(results[0]).toHaveLength; // online_users is an array
      expect(results[1]).toBe('delay');
      expect(results[2].text).toBe('Concurrent test message');
      socket.disconnect();
    });
    test('should maintain stability under message flood', async () => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      await waitForSocketConnection(socket);
      socket.emit('join_room', {
        room: 'general'
      });
      await waitForEvent(socket, 'online_users');
      const messagePromises = [];
      for (let i = 0; i < 10; i++) {
        messagePromises.push(retryOperation(async () => {
          socket.emit('message', {
            text: `Flood test ${i}`
          });
          return waitForEvent(socket, 'message');
        }));
      }

      // Use Promise.allSettled for messages that might timeout
      const results = await Promise.allSettled(messagePromises);
      const successful = results.filter(r => r.status === 'fulfilled').length;
      expect(successful).toBeGreaterThan(5); // At least 50% success rate

      socket.disconnect();
    });
    test('should handle network disconnection gracefully', async () => {
      const socket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      await waitForSocketConnection(socket);
      socket.emit('join_room', {
        room: 'general'
      });
      await waitForEvent(socket, 'online_users');

      // Simulate network disconnection by disconnecting
      socket.disconnect();

      // Wait for disconnect event
      await waitForEvent(socket, 'disconnect');

      // Should be able to reconnect
      const newSocket = io(`http://localhost:${serverPort}`, {
        auth: {
          token: testToken
        },
        forceNew: true
      });
      await waitForSocketConnection(newSocket, 10000); // Longer timeout
      expect(newSocket.connected).toBe(true);
      newSocket.disconnect();
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpbyIsInJlcXVpcmUiLCJqd3QiLCJjb25uZWN0REIiLCJjbG9zZURCIiwiVXNlciIsIkNoYW5uZWwiLCJNZXNzYWdlIiwiU29ja2V0VGVzdFNlcnZlciIsIndhaXRGb3JFdmVudCIsInNvY2tldCIsImV2ZW50TmFtZSIsInRpbWVvdXQiLCJyZXRyeUNvdW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXNvbHZlZCIsImF0dGVtcHRzIiwiY2xlYW51cCIsIm9mZiIsImV2ZW50SGFuZGxlciIsImNsZWFyVGltZW91dCIsInRpbWVvdXRJZCIsImRhdGEiLCJ0cnlXYWl0Iiwic2V0VGltZW91dCIsIkVycm9yIiwib25jZSIsIndhaXRGb3JTb2NrZXRDb25uZWN0aW9uIiwiY29ubmVjdGVkIiwiY29ubmVjdEhhbmRsZXIiLCJlcnJvckhhbmRsZXIiLCJlcnJvciIsIm1lc3NhZ2UiLCJvbiIsInNpbXVsYXRlTGF0ZW5jeSIsImxhdGVuY3kiLCJvcmlnaW5hbEVtaXQiLCJlbWl0IiwiYmluZCIsImFyZ3MiLCJyZXRyeU9wZXJhdGlvbiIsIm9wZXJhdGlvbiIsIm1heFJldHJpZXMiLCJkZWxheSIsImF0dGVtcHQiLCJ0ZXN0U2VydmVyIiwidGVzdFVzZXIiLCJ0ZXN0VG9rZW4iLCJzZXJ2ZXJQb3J0IiwiZGVzY3JpYmUiLCJiZWZvcmVBbGwiLCJqZXN0Iiwic3RhcnQiLCJuaWNrbmFtZSIsImVtYWlsIiwicGFzc3dvcmQiLCJzdGF0dXMiLCJzYXZlIiwiZmluZE9uZUFuZFVwZGF0ZSIsImlkIiwibmFtZSIsInR5cGUiLCJjcmVhdGVkQnkiLCJ1cHNlcnQiLCJuZXciLCJjb25zb2xlIiwid2FybiIsInNpZ24iLCJfaWQiLCJyb2xlIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJleHBpcmVzSW4iLCJhZnRlckFsbCIsInN0b3AiLCJ0ZXN0IiwiaW52YWxpZFNvY2tldCIsImF1dGgiLCJ0b2tlbiIsImZvcmNlTmV3IiwiY2F1Z2h0RXJyb3IiLCJleHBlY3QiLCJyZWplY3RzIiwidG9UaHJvdyIsInRvQmVUcnV0aHkiLCJkaXNjb25uZWN0Iiwibm9Ub2tlblNvY2tldCIsImNsaWVudFNvY2tldCIsInNlY29uZFNvY2tldCIsImJlZm9yZUVhY2giLCJkb25lIiwic2Vjb25kVXNlciIsInRoZW4iLCJzZWNvbmRUb2tlbiIsInJvb20iLCJsb2dnZXIiLCJpbmZvIiwic3Vic3RyaW5nIiwiYWZ0ZXJFYWNoIiwicHJpdmF0ZU1lc3NhZ2UiLCJhbGwiLCJ0byIsInRleHQiLCJzZW5kZXJEYXRhIiwicmVjZWl2ZXJEYXRhIiwidG9CZSIsImF1dGhvciIsImZyb20iLCJoaXN0b3J5IiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidG9IYXZlUHJvcGVydHkiLCJtZXNzYWdlcyIsImNvZGUiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25EZWxheSIsIm5ld1NvY2tldCIsInRvdGFsU29ja2V0cyIsInNvY2tldHMiLCJjb25uZWN0aW9uUHJvbWlzZXMiLCJfIiwiaSIsInB1c2giLCJmb3JFYWNoIiwic29jayIsImNoYW5uZWxJZCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJvcGVyYXRpb25Db3VudCIsInRhcmdldE9wZXJhdGlvbnMiLCJwZXJmb3JtT3BlcmF0aW9uIiwiZW5kVGltZSIsImR1cmF0aW9uIiwidG9CZUxlc3NUaGFuIiwibWFsZm9ybWVkTWVzc2FnZXMiLCJ1bmRlZmluZWQiLCJtYWxmb3JtZWQiLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsIm1vY2tPcGVyYXRpb24iLCJyZXN1bHQiLCJwcm9taXNlcyIsInJlc3VsdHMiLCJ0b0hhdmVMZW5ndGgiLCJtZXNzYWdlUHJvbWlzZXMiLCJhbGxTZXR0bGVkIiwic3VjY2Vzc2Z1bCIsImZpbHRlciIsInIiLCJ0b0JlR3JlYXRlclRoYW4iXSwic291cmNlcyI6WyJzb2NrZXQtZXh0ZW5kZWQudGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbyA9IHJlcXVpcmUoJ3NvY2tldC5pby1jbGllbnQnKTtcbmNvbnN0IGp3dCA9IHJlcXVpcmUoJ2pzb253ZWJ0b2tlbicpO1xuY29uc3QgeyBjb25uZWN0REIsIGNsb3NlREIgfSA9IHJlcXVpcmUoJy4uL2RiL2Nvbm5lY3Rpb24nKTtcbmNvbnN0IFVzZXIgPSByZXF1aXJlKCcuLi9tb2RlbHMvVXNlcicpO1xuY29uc3QgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL21vZGVscy9DaGFubmVsJyk7XG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi4vbW9kZWxzL01lc3NhZ2UnKTtcbmNvbnN0IFNvY2tldFRlc3RTZXJ2ZXIgPSByZXF1aXJlKCcuL3NvY2tldC1zZXJ2ZXIudGVzdCcpO1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHdhaXQgZm9yIHNvY2tldCBldmVudCB3aXRoIHRpbWVvdXQgYW5kIHJldHJ5XG5mdW5jdGlvbiB3YWl0Rm9yRXZlbnQoc29ja2V0LCBldmVudE5hbWUsIHRpbWVvdXQgPSA1MDAwLCByZXRyeUNvdW50ID0gMykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuICAgIGxldCBhdHRlbXB0cyA9IDA7XG5cbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgc29ja2V0Lm9mZihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGRhdGEpID0+IHtcbiAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHRyeVdhaXQgPSAoKSA9PiB7XG4gICAgICBpZiAocmVzb2x2ZWQgfHwgYXR0ZW1wdHMgPj0gcmV0cnlDb3VudCkgcmV0dXJuO1xuXG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgICAgaWYgKGF0dGVtcHRzIDwgcmV0cnlDb3VudCkge1xuICAgICAgICAgICAgdHJ5V2FpdCgpOyAvLyBSZXRyeVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBFdmVudCAnJHtldmVudE5hbWV9JyBub3QgcmVjZWl2ZWQgYWZ0ZXIgJHtyZXRyeUNvdW50fSBhdHRlbXB0cyAoJHt0aW1lb3V0ICogcmV0cnlDb3VudH1tcylgKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICBzb2NrZXQub25jZShldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRyeVdhaXQoKTtcbiAgfSk7XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gd2FpdCBmb3Igc29ja2V0IGNvbm5lY3Rpb24gd2l0aCB0aW1lb3V0XG5mdW5jdGlvbiB3YWl0Rm9yU29ja2V0Q29ubmVjdGlvbihzb2NrZXQsIHRpbWVvdXQgPSA1MDAwKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHNvY2tldC5jb25uZWN0ZWQpIHtcbiAgICAgIHJlc29sdmUoc29ja2V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICBsZXQgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIHNvY2tldC5vZmYoJ2Nvbm5lY3QnLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICBzb2NrZXQub2ZmKCdjb25uZWN0X2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH07XG5cbiAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUoc29ja2V0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGVycm9yKSA9PiB7XG4gICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBTb2NrZXQgY29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgU29ja2V0IGNvbm5lY3Rpb24gdGltZW91dCBhZnRlciAke3RpbWVvdXR9bXNgKSk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBjb25uZWN0SGFuZGxlcik7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0X2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgfSk7XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gc2ltdWxhdGUgbmV0d29yayBsYXRlbmN5XG5mdW5jdGlvbiBzaW11bGF0ZUxhdGVuY3koc29ja2V0LCBsYXRlbmN5ID0gMTAwKSB7XG4gIGNvbnN0IG9yaWdpbmFsRW1pdCA9IHNvY2tldC5lbWl0LmJpbmQoc29ja2V0KTtcbiAgc29ja2V0LmVtaXQgPSAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvcmlnaW5hbEVtaXQoLi4uYXJncyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIGxhdGVuY3kpO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBSZXRyeSB1dGlsaXR5IGZvciBvcGVyYXRpb25zXG5hc3luYyBmdW5jdGlvbiByZXRyeU9wZXJhdGlvbihvcGVyYXRpb24sIG1heFJldHJpZXMgPSAzLCBkZWxheSA9IDEwMDApIHtcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IG9wZXJhdGlvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoYXR0ZW1wdCA9PT0gbWF4UmV0cmllcyAtIDEpIHRocm93IGVycm9yO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgfVxuICB9XG59XG5cbmxldCB0ZXN0U2VydmVyO1xubGV0IHRlc3RVc2VyO1xubGV0IHRlc3RUb2tlbjtcbmxldCBzZXJ2ZXJQb3J0O1xuXG5kZXNjcmliZSgnU29ja2V0LklPIEV4dGVuZGVkIFRlc3RzIC0gSW1wcm92ZWQgU3RhYmlsaXR5JywgKCkgPT4ge1xuICBiZWZvcmVBbGwoYXN5bmMgKCkgPT4ge1xuICAgIGplc3Quc2V0VGltZW91dCg5MDAwMCk7IC8vIEluY3JlYXNlIHRpbWVvdXQgZm9yIGZ1bGwgdGVzdCBzdWl0ZVxuXG4gICAgYXdhaXQgcmV0cnlPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgY29ubmVjdERCKCk7XG4gICAgfSwgMywgMjAwMCk7XG5cbiAgICB0ZXN0U2VydmVyID0gbmV3IFNvY2tldFRlc3RTZXJ2ZXIoKTtcbiAgICBzZXJ2ZXJQb3J0ID0gYXdhaXQgcmV0cnlPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRlc3RTZXJ2ZXIuc3RhcnQoKTtcbiAgICB9LCAzLCAyMDAwKTtcblxuICAgIHRlc3RVc2VyID0gbmV3IFVzZXIoe1xuICAgICAgbmlja25hbWU6ICdleHRlbmRlZFNvY2tldFRlc3RVc2VyJyxcbiAgICAgIGVtYWlsOiAnZXh0ZW5kZWQtc29ja2V0QHRlc3QuY29tJyxcbiAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3MxMjMnLFxuICAgICAgc3RhdHVzOiAnb25saW5lJ1xuICAgIH0pO1xuICAgIGF3YWl0IHRlc3RVc2VyLnNhdmUoKTtcblxuICAgIC8vIENyZWF0ZSB0ZXN0IGNoYW5uZWxzIHdpdGggYmV0dGVyIGVycm9yIGhhbmRsaW5nXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IENoYW5uZWwuZmluZE9uZUFuZFVwZGF0ZShcbiAgICAgICAgeyBpZDogJ2dlbmVyYWwnIH0sXG4gICAgICAgIHsgaWQ6ICdnZW5lcmFsJywgbmFtZTogJ0dlbmVyYWwgQ2hhdCcsIHR5cGU6ICd0ZXh0JywgY3JlYXRlZEJ5OiAnc3lzdGVtJyB9LFxuICAgICAgICB7IHVwc2VydDogdHJ1ZSwgbmV3OiB0cnVlIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IENoYW5uZWwuZmluZE9uZUFuZFVwZGF0ZShcbiAgICAgICAgeyBpZDogJ3ZvaWNlLWNoYXQnIH0sXG4gICAgICAgIHsgaWQ6ICd2b2ljZS1jaGF0JywgbmFtZTogJ1ZvaWNlIENoYXQnLCB0eXBlOiAndm9pY2UnLCBjcmVhdGVkQnk6ICdzeXN0ZW0nIH0sXG4gICAgICAgIHsgdXBzZXJ0OiB0cnVlLCBuZXc6IHRydWUgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgQ2hhbm5lbC5maW5kT25lQW5kVXBkYXRlKFxuICAgICAgICB7IGlkOiAncHJpdmF0ZS10ZXN0JyB9LFxuICAgICAgICB7IGlkOiAncHJpdmF0ZS10ZXN0JywgbmFtZTogJ1ByaXZhdGUgVGVzdCcsIHR5cGU6ICd0ZXh0JywgY3JlYXRlZEJ5OiAnc3lzdGVtJyB9LFxuICAgICAgICB7IHVwc2VydDogdHJ1ZSwgbmV3OiB0cnVlIH1cbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2hhbm5lbCBjcmVhdGlvbiB3YXJuaW5nOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBKV1QgdG9rZW5cbiAgICB0ZXN0VG9rZW4gPSBqd3Quc2lnbihcbiAgICAgIHsgaWQ6IHRlc3RVc2VyLl9pZCwgbmlja25hbWU6IHRlc3RVc2VyLm5pY2tuYW1lLCByb2xlOiB0ZXN0VXNlci5yb2xlIH0sXG4gICAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVULFxuICAgICAgeyBleHBpcmVzSW46ICcyNGgnIH1cbiAgICApO1xuICB9KTtcblxuICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgaWYgKHRlc3RTZXJ2ZXIpIHtcbiAgICAgIGF3YWl0IHRlc3RTZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICBhd2FpdCBjbG9zZURCKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBdXRoZW50aWNhdGlvbiBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBKV1QgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkU29ja2V0ID0gaW8oYGh0dHA6Ly9sb2NhbGhvc3Q6JHtzZXJ2ZXJQb3J0fWAsIHtcbiAgICAgICAgYXV0aDogeyB0b2tlbjogJ2ludmFsaWQtdG9rZW4nIH0sXG4gICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgbGV0IGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIGludmFsaWRTb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXYWl0IGZvciBjb25uZWN0aW9uIGF0dGVtcHQgdG8gZmFpbFxuICAgICAgYXdhaXQgZXhwZWN0KHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKGludmFsaWRTb2NrZXQsIDMwMDApKS5yZWplY3RzLnRvVGhyb3coKTtcblxuICAgICAgZXhwZWN0KGNhdWdodEVycm9yKS50b0JlVHJ1dGh5KCk7XG4gICAgICBpbnZhbGlkU29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgY29ubmVjdGlvbiB3aXRob3V0IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgbm9Ub2tlblNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7c2VydmVyUG9ydH1gLCB7XG4gICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgbGV0IGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIG5vVG9rZW5Tb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qod2FpdEZvclNvY2tldENvbm5lY3Rpb24obm9Ub2tlblNvY2tldCwgMzAwMCkpLnJlamVjdHMudG9UaHJvdygpO1xuXG4gICAgICBleHBlY3QoY2F1Z2h0RXJyb3IpLnRvQmVUcnV0aHkoKTtcbiAgICAgIG5vVG9rZW5Tb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICB9KTtcblxuXG4gIGRlc2NyaWJlKCdQcml2YXRlIE1lc3NhZ2VzIC0gL3cgQ29tbWFuZCBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGxldCBjbGllbnRTb2NrZXQsIHNlY29uZFNvY2tldDtcblxuICAgIGJlZm9yZUVhY2goKGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IHNlY29uZFVzZXIgPSBuZXcgVXNlcih7XG4gICAgICAgIG5pY2tuYW1lOiAnZXh0ZW5kZWRUZXN0VXNlcjInLFxuICAgICAgICBlbWFpbDogJ2V4dGVuZGVkLXRlc3QyQHRlc3QuY29tJyxcbiAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzczEyMycsXG4gICAgICAgIHN0YXR1czogJ29ubGluZSdcbiAgICAgIH0pO1xuXG4gICAgICBzZWNvbmRVc2VyLnNhdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2Vjb25kVG9rZW4gPSBqd3Quc2lnbihcbiAgICAgICAgICB7IGlkOiBzZWNvbmRVc2VyLl9pZCwgbmlja25hbWU6IHNlY29uZFVzZXIubmlja25hbWUsIHJvbGU6IHNlY29uZFVzZXIucm9sZSB9LFxuICAgICAgICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQsXG4gICAgICAgICAgeyBleHBpcmVzSW46ICcyNGgnIH1cbiAgICAgICAgKTtcblxuICAgICAgICBjbGllbnRTb2NrZXQgPSBpbyhgaHR0cDovL2xvY2FsaG9zdDoke3NlcnZlclBvcnR9YCwge1xuICAgICAgICAgIGF1dGg6IHsgdG9rZW46IHRlc3RUb2tlbiB9LFxuICAgICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlY29uZFNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7c2VydmVyUG9ydH1gLCB7XG4gICAgICAgICAgYXV0aDogeyB0b2tlbjogc2Vjb25kVG9rZW4gfSxcbiAgICAgICAgICBmb3JjZU5ldzogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBzZWNvbmRTb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgY2xpZW50U29ja2V0LmVtaXQoJ2pvaW5fcm9vbScsIHsgcm9vbTogJ2dlbmVyYWwnIH0pO1xuICAgICAgICAgIHNlY29uZFNvY2tldC5lbWl0KCdqb2luX3Jvb20nLCB7IHJvb206ICdnZW5lcmFsJyB9KTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKCdDb25uZWN0aW5nIHNlY29uZERlYnVnZ2VyIHNvY2tldCB3aXRoIHRva2VuOicsIHNlY29uZFRva2VuLnN1YnN0cmluZygwLCAyMCkgKyAnLi4uJyk7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdUZXN0VXNlciBJRDonLCB0ZXN0VXNlci5faWQsICdTdGF0dXM6JywgdGVzdFVzZXIuc3RhdHVzKTtcblxuICAgICAgICBzZWNvbmRTb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBkb25lKG5ldyBFcnJvcihgU2Vjb25kIHNvY2tldCBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgXG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgaWYgKGNsaWVudFNvY2tldCkgY2xpZW50U29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGlmIChzZWNvbmRTb2NrZXQpIHNlY29uZFNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgc2VuZCBwcml2YXRlIG1lc3NhZ2UgYmV0d2VlbiB1c2VycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByaXZhdGVNZXNzYWdlID0gJ1ByaXZhdGUgbWVzc2FnZSBmcm9tIGV4dGVuZGVkIHRlc3QnO1xuXG4gICAgICAvLyBXYWl0IGZvciBib3RoIHNvY2tldHMgdG8gYmUgcmVhZHlcbiAgICAgIGF3YWl0IHJldHJ5T3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKGNsaWVudFNvY2tldCksXG4gICAgICAgICAgd2FpdEZvclNvY2tldENvbm5lY3Rpb24oc2Vjb25kU29ja2V0KVxuICAgICAgICBdKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFbWl0IHRoZSBtZXNzYWdlXG4gICAgICBjbGllbnRTb2NrZXQuZW1pdCgncHJpdmF0ZV9tZXNzYWdlJywge1xuICAgICAgICB0bzogJ2V4dGVuZGVkVGVzdFVzZXIyJyxcbiAgICAgICAgdGV4dDogcHJpdmF0ZU1lc3NhZ2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXYWl0IGZvciBib3RoIHNpZGVzIHRvIHJlY2VpdmUgdGhlIG1lc3NhZ2VcbiAgICAgIGNvbnN0IFtzZW5kZXJEYXRhLCByZWNlaXZlckRhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB3YWl0Rm9yRXZlbnQoY2xpZW50U29ja2V0LCAncHJpdmF0ZV9tZXNzYWdlJyksXG4gICAgICAgIHdhaXRGb3JFdmVudChzZWNvbmRTb2NrZXQsICdwcml2YXRlX21lc3NhZ2UnKVxuICAgICAgXSk7XG5cbiAgICAgIGV4cGVjdChzZW5kZXJEYXRhLnRleHQpLnRvQmUocHJpdmF0ZU1lc3NhZ2UpO1xuICAgICAgZXhwZWN0KHJlY2VpdmVyRGF0YS50ZXh0KS50b0JlKHByaXZhdGVNZXNzYWdlKTtcbiAgICAgIGV4cGVjdChyZWNlaXZlckRhdGEuYXV0aG9yKS50b0JlKHRlc3RVc2VyLm5pY2tuYW1lKTtcbiAgICAgIGV4cGVjdChyZWNlaXZlckRhdGEuZnJvbSB8fCByZWNlaXZlckRhdGEuYXV0aG9yKS50b0JlKHRlc3RVc2VyLm5pY2tuYW1lKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01lc3NhZ2UgSGlzdG9yeSBhbmQgQXJjaGl2YWwnLCAoKSA9PiB7XG4gICAgbGV0IGNsaWVudFNvY2tldDtcblxuICAgIGJlZm9yZUVhY2goKGRvbmUpID0+IHtcbiAgICAgIGNsaWVudFNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7c2VydmVyUG9ydH1gLCB7XG4gICAgICAgIGF1dGg6IHsgdG9rZW46IHRlc3RUb2tlbiB9LFxuICAgICAgICBmb3JjZU5ldzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNsaWVudFNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNsaWVudFNvY2tldC5vbignY29ubmVjdF9lcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICBkb25lKG5ldyBFcnJvcihgQ29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBpZiAoY2xpZW50U29ja2V0KSBjbGllbnRTb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlY2VpdmUgaGlzdG9yeSB3aGVuIGpvaW5pbmcgcm9vbScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNlbmQgYSB0ZXN0IG1lc3NhZ2UgZmlyc3RcbiAgICAgIGF3YWl0IHJldHJ5T3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclNvY2tldENvbm5lY3Rpb24oY2xpZW50U29ja2V0KTtcbiAgICAgIH0pO1xuXG4gICAgICBjbGllbnRTb2NrZXQuZW1pdCgnam9pbl9yb29tJywgeyByb29tOiAnZ2VuZXJhbCcgfSk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGhpc3RvcnkgZXZlbnRcbiAgICAgIGNvbnN0IGhpc3RvcnkgPSBhd2FpdCB3YWl0Rm9yRXZlbnQoY2xpZW50U29ja2V0LCAnaGlzdG9yeScpO1xuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkoaGlzdG9yeSkpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAoaGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV4cGVjdChoaXN0b3J5WzBdKS50b0hhdmVQcm9wZXJ0eSgnYXV0aG9yJyk7XG4gICAgICAgIGV4cGVjdChoaXN0b3J5WzBdKS50b0hhdmVQcm9wZXJ0eSgndGV4dCcpO1xuICAgICAgICBleHBlY3QoaGlzdG9yeVswXSkudG9IYXZlUHJvcGVydHkoJ3RpbWVzdGFtcCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBoaXN0b3J5IHJlcXVlc3Qgd2l0aG91dCByb29tJywgKGRvbmUpID0+IHtcbiAgICAgIGNsaWVudFNvY2tldC5lbWl0KCdnZXRfaGlzdG9yeScpO1xuXG4gICAgICBjbGllbnRTb2NrZXQub24oJ2hpc3RvcnknLCAobWVzc2FnZXMpID0+IHtcbiAgICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkobWVzc2FnZXMpKS50b0JlKHRydWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Jvb20gU3dpdGNoaW5nIGFuZCBDaGFubmVsIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHJvb20gbmFtZXMnLCAoZG9uZSkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oYGh0dHA6Ly9sb2NhbGhvc3Q6JHtzZXJ2ZXJQb3J0fWAsIHtcbiAgICAgICAgYXV0aDogeyB0b2tlbjogdGVzdFRva2VuIH0sXG4gICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQuZW1pdCgnam9pbl9yb29tJywgeyByb29tOiAnJyB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBleHBlY3QoZGF0YS5jb2RlKS50b0JlKCdJTlZBTElEX1JPT01fRk9STUFUJyk7XG4gICAgICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignY29ubmVjdF9lcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICBkb25lKG5ldyBFcnJvcihgQ29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbm9uLWV4aXN0ZW50IGNoYW5uZWwnLCAoZG9uZSkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oYGh0dHA6Ly9sb2NhbGhvc3Q6JHtzZXJ2ZXJQb3J0fWAsIHtcbiAgICAgICAgYXV0aDogeyB0b2tlbjogdGVzdFRva2VuIH0sXG4gICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQuZW1pdCgnam9pbl9yb29tJywgeyByb29tOiAnbm9uLWV4aXN0ZW50LWNoYW5uZWwnIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIGV4cGVjdChkYXRhLmNvZGUpLnRvQmUoJ0NIQU5ORUxfTk9UX0ZPVU5EJyk7XG4gICAgICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25uZWN0aW9uIE1hbmFnZW1lbnQgYW5kIFJlY292ZXJ5JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgY29ubmVjdGlvbiByZWNvdmVyeSBhZnRlciBkaXNjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oYGh0dHA6Ly9sb2NhbGhvc3Q6JHtzZXJ2ZXJQb3J0fWAsIHtcbiAgICAgICAgYXV0aDogeyB0b2tlbjogdGVzdFRva2VuIH0sXG4gICAgICAgIGZvcmNlTmV3OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yU29ja2V0Q29ubmVjdGlvbihzb2NrZXQpO1xuICAgICAgZXhwZWN0KHNvY2tldC5jb25uZWN0ZWQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIERpc2Nvbm5lY3QgYW5kIHdhaXQgZm9yIHJlY29ubmVjdGlvblxuICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcblxuICAgICAgLy8gV2FpdCBmb3IgZGlzY29ubmVjdCBldmVudFxuICAgICAgYXdhaXQgd2FpdEZvckV2ZW50KHNvY2tldCwgJ2Rpc2Nvbm5lY3QnKTtcblxuICAgICAgLy8gQ3JlYXRlIG5ldyBjb25uZWN0aW9uIChhdXRvbWF0aWMgcmVjb25uZWN0aW9uIHdvdWxkIGJlIGlkZWFsIGJ1dCBtYXkgbm90IHdvcmsgcmVsaWFibHkpXG4gICAgICBjb25zdCBuZXdTb2NrZXQgPSBpbyhgaHR0cDovL2xvY2FsaG9zdDoke3NlcnZlclBvcnR9YCwge1xuICAgICAgICBhdXRoOiB7IHRva2VuOiB0ZXN0VG9rZW4gfSxcbiAgICAgICAgZm9yY2VOZXc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yU29ja2V0Q29ubmVjdGlvbihuZXdTb2NrZXQpO1xuICAgICAgZXhwZWN0KG5ld1NvY2tldC5jb25uZWN0ZWQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIG5ld1NvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHJhcGlkIGNvbm5lY3Rpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdG90YWxTb2NrZXRzID0gMztcbiAgICAgIGNvbnN0IHNvY2tldHMgPSBbXTtcblxuICAgICAgLy8gQ3JlYXRlIGFsbCBzb2NrZXRzIGF0IG9uY2UgdXNpbmcgUHJvbWlzZS5hbGxcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25Qcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRvdGFsU29ja2V0cyB9LCBhc3luYyAoXywgaSkgPT4ge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBpbyhgaHR0cDovL2xvY2FsaG9zdDoke3NlcnZlclBvcnR9YCwge1xuICAgICAgICAgIGF1dGg6IHsgdG9rZW46IHRlc3RUb2tlbiB9LFxuICAgICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKHNvY2tldCk7XG4gICAgICAgIHNvY2tldHMucHVzaChzb2NrZXQpO1xuICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGFsbCBjb25uZWN0aW9ucyBzaW11bHRhbmVvdXNseVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29ubmVjdGlvblByb21pc2VzKTtcbiAgICAgIGV4cGVjdChzb2NrZXRzLmxlbmd0aCkudG9CZSh0b3RhbFNvY2tldHMpO1xuXG4gICAgICAvLyBDbGVhbiB1cFxuICAgICAgc29ja2V0cy5mb3JFYWNoKHNvY2sgPT4gc29jay5kaXNjb25uZWN0KCkpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWR2YW5jZWQgVm9pY2UgQ2hhbm5lbCBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBqb2luaW5nIHRleHQgY2hhbm5lbCBhcyB2b2ljZSBjaGFubmVsJywgKGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7c2VydmVyUG9ydH1gLCB7XG4gICAgICAgIGF1dGg6IHsgdG9rZW46IHRlc3RUb2tlbiB9LFxuICAgICAgICBmb3JjZU5ldzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5fdm9pY2VfY2hhbm5lbCcsIHsgY2hhbm5lbElkOiAnZ2VuZXJhbCcgfSk7IC8vIFRleHQgY2hhbm5lbFxuICAgICAgICBzb2NrZXQub24oJ3ZvaWNlX2Vycm9yJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBleHBlY3QoZGF0YS5tZXNzYWdlKS50b0JlKCdWb2ljZSBjaGFubmVsIG5vdCBmb3VuZCcpO1xuICAgICAgICAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGpvaW4gdm9pY2UgY2hhbm5lbCB3aXRob3V0IHJvb20gZmlyc3QnLCAoZG9uZSkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oYGh0dHA6Ly9sb2NhbGhvc3Q6JHtzZXJ2ZXJQb3J0fWAsIHtcbiAgICAgICAgYXV0aDogeyB0b2tlbjogdGVzdFRva2VuIH0sXG4gICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQuZW1pdCgnam9pbl92b2ljZV9jaGFubmVsJywgeyBjaGFubmVsSWQ6ICd2b2ljZS1jaGF0JyB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ3ZvaWNlX2pvaW5lZCcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGRhdGEuY2hhbm5lbElkKS50b0JlKCd2b2ljZS1jaGF0Jyk7XG4gICAgICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSYXRlIExpbWl0aW5nIGFuZCBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgbWFpbnRhaW4gcGVyZm9ybWFuY2UgdW5kZXIgbG9hZCcsIChkb25lKSA9PiB7XG4gICAgICBjb25zdCBzb2NrZXQgPSBpbyhgaHR0cDovL2xvY2FsaG9zdDoke3NlcnZlclBvcnR9YCwge1xuICAgICAgICBhdXRoOiB7IHRva2VuOiB0ZXN0VG9rZW4gfSxcbiAgICAgICAgZm9yY2VOZXc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBvcGVyYXRpb25Db3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHRhcmdldE9wZXJhdGlvbnMgPSAyMDtcblxuICAgICAgICBjb25zdCBwZXJmb3JtT3BlcmF0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC5lbWl0KCdtZXNzYWdlJywgeyB0ZXh0OiBgTG9hZCB0ZXN0ICR7b3BlcmF0aW9uQ291bnQgKyAxfWAgfSk7XG4gICAgICAgICAgb3BlcmF0aW9uQ291bnQrKztcblxuICAgICAgICAgIGlmIChvcGVyYXRpb25Db3VudCA+PSB0YXJnZXRPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKDUwMDApOyAvLyA1IHNlY29uZHMgbWF4XG4gICAgICAgICAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBlcmZvcm1PcGVyYXRpb24sIDUwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5fcm9vbScsIHsgcm9vbTogJ2dlbmVyYWwnIH0pO1xuICAgICAgICBzb2NrZXQub24oJ29ubGluZV91c2VycycsICgpID0+IHtcbiAgICAgICAgICBwZXJmb3JtT3BlcmF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignY29ubmVjdF9lcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICBkb25lKG5ldyBFcnJvcihgQ29ubmVjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIFJlY292ZXJ5IGFuZCBSZXNpbGllbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIG1lc3NhZ2VzIGdyYWNlZnVsbHknLCAoZG9uZSkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oYGh0dHA6Ly9sb2NhbGhvc3Q6JHtzZXJ2ZXJQb3J0fWAsIHtcbiAgICAgICAgYXV0aDogeyB0b2tlbjogdGVzdFRva2VuIH0sXG4gICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQuZW1pdCgnam9pbl9yb29tJywgeyByb29tOiAnZ2VuZXJhbCcgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdvbmxpbmVfdXNlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWFsZm9ybWVkTWVzc2FnZXMgPSBbbnVsbCwgdW5kZWZpbmVkLCB7IHRleHQ6ICcnIH0sIHsgdGV4dDogJyAgICcgfSwge31dO1xuXG4gICAgICAgICAgbWFsZm9ybWVkTWVzc2FnZXMuZm9yRWFjaCgobWFsZm9ybWVkKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnbWVzc2FnZScsIG1hbGZvcm1lZCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpOyAvLyBUZXN0IHBhc3NlcyBpZiBubyBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgZG9uZShuZXcgRXJyb3IoYENvbm5lY3Rpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdOZXR3b3JrIENvbmRpdGlvbnMgRW11bGF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgaGlnaCBsYXRlbmN5IGNvbm5lY3Rpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc29ja2V0ID0gaW8oYGh0dHA6Ly9sb2NhbGhvc3Q6JHtzZXJ2ZXJQb3J0fWAsIHtcbiAgICAgICAgYXV0aDogeyB0b2tlbjogdGVzdFRva2VuIH0sXG4gICAgICAgIGZvcmNlTmV3OiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgLy8gU2ltdWxhdGUgbGF0ZW5jeSBieSBtb25rZXktcGF0Y2hpbmcgdGhlIGVtaXQgbWV0aG9kXG4gICAgICBzaW11bGF0ZUxhdGVuY3koc29ja2V0KTtcblxuICAgICAgYXdhaXQgd2FpdEZvclNvY2tldENvbm5lY3Rpb24oc29ja2V0LCAxMDAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0IGZvciBsYXRlbmN5XG5cbiAgICAgIHNvY2tldC5lbWl0KCdqb2luX3Jvb20nLCB7IHJvb206ICdnZW5lcmFsJyB9KTtcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHdhaXRGb3JFdmVudChzb2NrZXQsICdtZXNzYWdlJywgMTAwMDApO1xuICAgICAgZXhwZWN0KGRhdGEuYXV0aG9yKS50b0JlKCdTeXN0ZW0nKTtcblxuICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgY29ubmVjdGlvbiBkcm9wcyBhbmQgcmVjb3ZlcnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzb2NrZXQgPSBpbyhgaHR0cDovL2xvY2FsaG9zdDoke3NlcnZlclBvcnR9YCwge1xuICAgICAgICBhdXRoOiB7IHRva2VuOiB0ZXN0VG9rZW4gfSxcbiAgICAgICAgZm9yY2VOZXc6IHRydWUsXG4gICAgICAgIHJlY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgcmVjb25uZWN0aW9uRGVsYXk6IDEwMCxcbiAgICAgICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IDVcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yU29ja2V0Q29ubmVjdGlvbihzb2NrZXQpO1xuXG4gICAgICBzb2NrZXQuZW1pdCgnam9pbl9yb29tJywgeyByb29tOiAnZ2VuZXJhbCcgfSk7XG4gICAgICBhd2FpdCB3YWl0Rm9yRXZlbnQoc29ja2V0LCAnb25saW5lX3VzZXJzJyk7XG5cbiAgICAgIC8vIEZvcmNlZnVsbHkgZGlzY29ubmVjdCB0aGUgc29ja2V0XG4gICAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuXG4gICAgICAvLyBUaGUgdGVzdCBwYXNzZXMgaWYgd2UgcmVhY2ggaGVyZSB3aXRob3V0IGhhbmdpbmdcbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHJ5IGZhaWxlZCBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJldHJ5Q291bnQgPSAwO1xuXG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIGlmIChyZXRyeUNvdW50IDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2ltdWxhdGVkIG5ldHdvcmsgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3N1Y2Nlc3MnO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnlPcGVyYXRpb24obW9ja09wZXJhdGlvbiwgMywgMTApOyAvLyBWZXJ5IHNob3J0IGRlbGF5IGZvciB0ZXN0aW5nXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdzdWNjZXNzJyk7XG4gICAgICBleHBlY3QocmV0cnlDb3VudCkudG9CZSgyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgc2ltdWx0YW5lb3VzIG9wZXJhdGlvbnMgd2l0aCBQcm9taXNlLmFsbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7c2VydmVyUG9ydH1gLCB7XG4gICAgICAgIGF1dGg6IHsgdG9rZW46IHRlc3RUb2tlbiB9LFxuICAgICAgICBmb3JjZU5ldzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKHNvY2tldCk7XG4gICAgICBzb2NrZXQuZW1pdCgnam9pbl9yb29tJywgeyByb29tOiAnZ2VuZXJhbCcgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBwcm9taXNlcyB0aGF0IHNob3VsZCBjb21wbGV0ZSBzaW11bHRhbmVvdXNseVxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXG4gICAgICAgIHdhaXRGb3JFdmVudChzb2NrZXQsICdvbmxpbmVfdXNlcnMnKSxcbiAgICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpLnRoZW4oKCkgPT4gJ2RlbGF5JyksXG4gICAgICAgIHJldHJ5T3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQuZW1pdCgnbWVzc2FnZScsIHsgdGV4dDogJ0NvbmN1cnJlbnQgdGVzdCBtZXNzYWdlJyB9KTtcbiAgICAgICAgICByZXR1cm4gd2FpdEZvckV2ZW50KHNvY2tldCwgJ21lc3NhZ2UnKTtcbiAgICAgICAgfSlcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBleHBlY3QocmVzdWx0c1swXSkudG9IYXZlTGVuZ3RoOyAvLyBvbmxpbmVfdXNlcnMgaXMgYW4gYXJyYXlcbiAgICAgIGV4cGVjdChyZXN1bHRzWzFdKS50b0JlKCdkZWxheScpO1xuICAgICAgZXhwZWN0KHJlc3VsdHNbMl0udGV4dCkudG9CZSgnQ29uY3VycmVudCB0ZXN0IG1lc3NhZ2UnKTtcblxuICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBtYWludGFpbiBzdGFiaWxpdHkgdW5kZXIgbWVzc2FnZSBmbG9vZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7c2VydmVyUG9ydH1gLCB7XG4gICAgICAgIGF1dGg6IHsgdG9rZW46IHRlc3RUb2tlbiB9LFxuICAgICAgICBmb3JjZU5ldzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKHNvY2tldCk7XG4gICAgICBzb2NrZXQuZW1pdCgnam9pbl9yb29tJywgeyByb29tOiAnZ2VuZXJhbCcgfSk7XG4gICAgICBhd2FpdCB3YWl0Rm9yRXZlbnQoc29ja2V0LCAnb25saW5lX3VzZXJzJyk7XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VQcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIG1lc3NhZ2VQcm9taXNlcy5wdXNoKHJldHJ5T3BlcmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQuZW1pdCgnbWVzc2FnZScsIHsgdGV4dDogYEZsb29kIHRlc3QgJHtpfWAgfSk7XG4gICAgICAgICAgcmV0dXJuIHdhaXRGb3JFdmVudChzb2NrZXQsICdtZXNzYWdlJyk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlIFByb21pc2UuYWxsU2V0dGxlZCBmb3IgbWVzc2FnZXMgdGhhdCBtaWdodCB0aW1lb3V0XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKG1lc3NhZ2VQcm9taXNlcyk7XG4gICAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpLmxlbmd0aDtcblxuICAgICAgZXhwZWN0KHN1Y2Nlc3NmdWwpLnRvQmVHcmVhdGVyVGhhbig1KTsgLy8gQXQgbGVhc3QgNTAlIHN1Y2Nlc3MgcmF0ZVxuXG4gICAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGRpc2Nvbm5lY3Rpb24gZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7c2VydmVyUG9ydH1gLCB7XG4gICAgICAgIGF1dGg6IHsgdG9rZW46IHRlc3RUb2tlbiB9LFxuICAgICAgICBmb3JjZU5ldzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKHNvY2tldCk7XG4gICAgICBzb2NrZXQuZW1pdCgnam9pbl9yb29tJywgeyByb29tOiAnZ2VuZXJhbCcgfSk7XG4gICAgICBhd2FpdCB3YWl0Rm9yRXZlbnQoc29ja2V0LCAnb25saW5lX3VzZXJzJyk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIG5ldHdvcmsgZGlzY29ubmVjdGlvbiBieSBkaXNjb25uZWN0aW5nXG4gICAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuXG4gICAgICAvLyBXYWl0IGZvciBkaXNjb25uZWN0IGV2ZW50XG4gICAgICBhd2FpdCB3YWl0Rm9yRXZlbnQoc29ja2V0LCAnZGlzY29ubmVjdCcpO1xuXG4gICAgICAvLyBTaG91bGQgYmUgYWJsZSB0byByZWNvbm5lY3RcbiAgICAgIGNvbnN0IG5ld1NvY2tldCA9IGlvKGBodHRwOi8vbG9jYWxob3N0OiR7c2VydmVyUG9ydH1gLCB7XG4gICAgICAgIGF1dGg6IHsgdG9rZW46IHRlc3RUb2tlbiB9LFxuICAgICAgICBmb3JjZU5ldzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKG5ld1NvY2tldCwgMTAwMDApOyAvLyBMb25nZXIgdGltZW91dFxuICAgICAgZXhwZWN0KG5ld1NvY2tldC5jb25uZWN0ZWQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIG5ld1NvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxFQUFFLEdBQUdDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQztBQUN0QyxNQUFNQyxHQUFHLEdBQUdELE9BQU8sQ0FBQyxjQUFjLENBQUM7QUFDbkMsTUFBTTtFQUFFRSxTQUFTO0VBQUVDO0FBQVEsQ0FBQyxHQUFHSCxPQUFPLENBQUMsa0JBQWtCLENBQUM7QUFDMUQsTUFBTUksSUFBSSxHQUFHSixPQUFPLENBQUMsZ0JBQWdCLENBQUM7QUFDdEMsTUFBTUssT0FBTyxHQUFHTCxPQUFPLENBQUMsbUJBQW1CLENBQUM7QUFDNUMsTUFBTU0sT0FBTyxHQUFHTixPQUFPLENBQUMsbUJBQW1CLENBQUM7QUFDNUMsTUFBTU8sZ0JBQWdCLEdBQUdQLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQzs7QUFFeEQ7QUFDQSxTQUFTUSxZQUFZQSxDQUFDQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsT0FBTyxHQUFHLElBQUksRUFBRUMsVUFBVSxHQUFHLENBQUMsRUFBRTtFQUN2RSxPQUFPLElBQUlDLE9BQU8sQ0FBQyxDQUFDQyxPQUFPLEVBQUVDLE1BQU0sS0FBSztJQUN0QyxJQUFJQyxRQUFRLEdBQUcsS0FBSztJQUNwQixJQUFJQyxRQUFRLEdBQUcsQ0FBQztJQUVoQixNQUFNQyxPQUFPLEdBQUdBLENBQUEsS0FBTTtNQUNwQlQsTUFBTSxDQUFDVSxHQUFHLENBQUNULFNBQVMsRUFBRVUsWUFBWSxDQUFDO01BQ25DQyxZQUFZLENBQUNDLFNBQVMsQ0FBQztJQUN6QixDQUFDO0lBRUQsTUFBTUYsWUFBWSxHQUFJRyxJQUFJLElBQUs7TUFDN0IsSUFBSSxDQUFDUCxRQUFRLEVBQUU7UUFDYkEsUUFBUSxHQUFHLElBQUk7UUFD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